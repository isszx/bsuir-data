<html>
<head>

<title>Язык XML. Просмотр XML - документов</title>

</head>
<body background="../fon.gif">
<p><div align="center"><b>2. Просмотр XML - документов</b></div></p><font size="-1">

<p align=justify>Как уже отмечалось, в отличии от HTML, XML никак не определяет способ отображения и использования описываемых с его помощью элементов документа, т.е.  программе-анализатору предоставляется возможность самой выбирать нужное оформление. Этого требует принцип независимости определения внутренней структуры документа от способов представления этой информации. Например, задавая в документе элемент <i>&lt;flower&gt;роза&lt;/flower&gt;</i>, мы лишь указываем, что <i>rose </i>в данном случае является цветком, но информации о том, как должен выглядеть данный элемент документа на экране клиента и должен ли он отображаться вообще, в таком определении нет.
<p align=justify>Для того, чтобы использовать данные, определяемые элементами XML, например, отображать их на экране пользователя, необходимо написать программу-анализатор, которая бы выполняла эти действия. Уже сегодня таких программ появилось достаточное количество и у разработчиков существует  возможность выбора наиболее подходящей из них для решения конкретных проблем
<p align=justify>Как уже отмечалось ранее, в общем случае,  программы- анализаторы можно разделить на две группы: верифицирующие(т.е. использующие  DTD- описания для определения корректности документа) и не верифицирующие. Если Вы создаете свой язык и описываете его грамматику на основе DTD, то для анализа документов, написанных на этом языке, безусловно, потребуется программа, проверяющая корректность составления документа. Но так как использование DTD в XML не является обязательным, то любой правильно оформленный документ может быть распознан и разобран программой, предназначенной для анализа XML- документов. В любом случае, используя универсальные XML- анализаторы, Вы можете быть уверенным в том, что если заданные в документе конструкции языка  являются синтаксически правильными, то программа-анализатор сможет правильно извлечь определяемые ими элементы документа и передать их прикладной программе, выполняющей необходимые действия по отображению. Т.е. после разбора документа в большинстве случаев, Вам предоставляется объектная модель, отображающая содержимое Вашего документа, и средства, необходимые для работы с ней (прохода по дереву элементов). При этом в некоторых анализаторах способ представления структуры документа основывается на спецификации DOM, описанной в[<a href="links.html">4</a>]. Поэтому у Вас появляется также возможность использовать строгую иерархическую модель DOM для построения собственных документов.
<p align=justify>Если речь идет о способах отображения информации, хранящейся в XML, то необходимо упомянуть разрабатываемый в настоящее время W3C стандарт стилевых таблиц для XML, которые предназначены для описания правил отображения элементов XML. Более подробно мы поговорим об XSL чуть позже.
<a name="p1">
<b>Использование msxml в IE 4</b>
<p align=justify>Если на Вашем компьютере установлен броузер Internet Explorer 4 (или более поздняя версия), то Вы можете использовать встроенный в этот броузер XML- анализатор msxml в своих сценариях, написанных на Java Script ил VBScript,. В настоящий момент существуют две его реализации, - одна предназначена для использования в виде написанного на C++ ActiveX- объекта(реализация на базе COM- технологии)  другая, написанная на Java, не зависит от платформы. Оба анализатора не сложны, имеют сравнительно небольшой размер - msxml на C++ занимает около 100k, версия на Java - 127k. Анализатор, написанный на C++, в текущей реализации не поддерживает DTD- правил, более компактный и быстрый, чем его Java-версия. Оба они имеют поддержку иностранных языков, т.е. в составе Internet Explorer C++- анализатор работает со всеми языками, "понимаемыми" броузерами, а анализатор на Java - с теми языками, с которыми может работать виртуальная Java-машина. 
<p align=justify>Т.к. обе версии разрабатывались параллельно, объектная модель, заложенная в основу каждой из них, внешне схожа, поэтому больших сложностей при переходе от одной версии к другой обычно не возникает.
<p align=justify>Рассмотрим основные свойства и методы, доступные JavaScript- сценарию в процессе  его выполнения на стороне броузера. В наших примерах мы будем использовать XML- анализатор в сценариях Java Script, т.к. этот способ более понятен и быстрее работает. Полное описание C++ интерфейсов анализатора доступны в документации по Internet Client SDK
<b>Объектная модель XML в Internet Explorer 4.0</b>
<p align=justify>Перед тем, как использовать свойства и методы анализатора, его необходимо создать. Делается это при помощи стандартного метода, предназначенного для создания ActiveX- объектов:
<pre>var mydoc = new ActiveXObject("msxml");
</pre>
<p align=justify>Если ActiveX- компонент был зарегистрирован на Вашей машине(или у Вас установлен броузер Internet Explorer 4), то в результате выполнения этой функции переменной mydoc будет присвоен объект, имеющий тип msxml, свойства и методы которого используются в дальнейшем для получения доступа к структуре XML- документа.
<p align=justify>В <a href="app3.html">Приложении 2</a> приведен полный текст сценария JavaScrtipt, выводящего на  экран броузера Internet Explorer 4.0 XML- документ, созданный в <a href="app2.html">Приложении 1</a>. Вы можете использовать этот пример и комментарии к нему в качестве еще одного средства для более быстрого понимания принципов использования свойств и методов объектов Microsoft XML и создания собственных сценариев.
<p align=justify>Объектная модель XML- анализатора Microsoft может быть представлена в виде следующего набора внутренних объектов: <i>XML Document</i>, <i>XML Element </i>и <i>Element Collection</i>. Объект XML Document содержит свойства и методы, необходимые нам для работы с XML- документом в целом. XML Element отвечает за работу с каждым из элементов XML- документа. Element Collection представляет из себя набор элементов, доступ к которым доступен при помощи имени или порядкового номера. В следующих примерах мы рассмотрим каждый из этих объектов подробнее.
<b><i>Свойства и методы документа(объект XML Document)</i></b>
<TABLE BORDER=1 WIDTH="100%">
<TR VALIGN="TOP">
<th>URL</th>
<td>Свойство, доступное для записи и чтения. Задает или возвращает URL обрабатываемого документа. В случае изменения этого свойства текущий документ уничтожается и начинается загрузка нового по указанному URL</TD>
</TR>
<TR VALIGN="TOP">
<th>root</th>
<td>Возвращает корневой элемент XML- документа</TD>
</TR>
<TR VALIGN="TOP">
<th>charset</th>
<td>Свойство, доступное для записи и чтения.Возвращает или устанавливает название текущее кодировочной таблицы согласно требованиям ISO.</TD>
</TR>
<TR VALIGN="TOP">
<th>version</th>
<td>Возвращает номер версии XML</TD>
</TR>
<TR VALIGN="TOP">
<th>doctype</th>
<td>Возвращает содержимое элемента !DOCTYPE</TD>
</TR>
<TR VALIGN="TOP">
<th>createElement()</th>
<td>Метод, позволяющий создать новый элемент, который будет добавлен в качестве дочернего для текущего элемента дерева. В качестве первого параметра задается тип элемента, в качестве второго - название элемента
<I><br>xml.createElement(0,"new_element")</I></TD>
</TR>
<TR VALIGN="TOP">
<th>fileSize</th>
<td>Возвращает размер XML- документа. Это свойство в C++- версии анализатора еще не реализовано</TD>
</TR>
<TR VALIGN="TOP">
<th>fileModifiedDate</th>
<td>Возвращает дату последнего изменения XML- документа. Это свойство в C++- версии анализатора еще не реализовано</TD>
</TR>
<TR VALIGN="TOP">
<th>fileUpdatedDate</th>
<td>Возвращает дату последнего обновления XML- документа. Это свойство в C++- версии анализатора еще не реализовано</TD>
</TR>
<TR VALIGN="TOP">
<th>mimeType</th>
<td>Возвращает MIME-тип(MIME- Multipurpose Internet Mail Extension, RFC 1341).Это свойство в C++- версии анализатора еще не реализовано</TD>
</TR>
</TABLE>
<p align=justify>Ниже приведен фрагмент JavaScript- сценария, использующего эти методы и свойства для вывода информации о текущем документе:
<pre>
var xmldoc = new ActiveXObject("msxml");
var xmlsrc = "http://localhost/xml/journal.xml";
xmldoc.URL = xmlsrc;
function viewProperties(){
this.document.writeln('&lt;center&gt;&lt;table width=90% &gt;');
this.document.writeln('&lt;tr&gt;');
this.document.writeln('&lt;td align="center" 
bgcolor="silver"&gt;Document URL&lt;/td&gt;
&lt;td align="center"&gt;'+xmldoc.URL+'&lt;/td&gt;&lt;/tr&gt;');
this.document.writeln('&lt;tr&gt;');
this.document.writeln('&lt;td align="center" 
bgcolor="silver"&gt;Document root&lt;/td&gt;
&lt;td align="center"&gt;'+xmldoc.root+'&lt;/td&gt;&lt;/tr&gt;');
this.document.writeln('&lt;tr&gt;');
this.document.writeln('&lt;td align="center" 
bgcolor="silver"&gt;Document doctype&lt;/td&gt;
&lt;td align="center"&gt;'+xmldoc.doctype+'&lt;/td&gt;&lt;/tr&gt;');
this.document.writeln('&lt;tr&gt;');
this.document.writeln('&lt;td align="center" 
bgcolor="silver"&gt;Document version&lt;/td&gt;
&lt;td align="center"&gt;'+xmldoc.version+'&lt;/td&gt;&lt;/tr&gt;');
this.document.writeln('&lt;tr&gt;');
this.document.writeln('&lt;td align="center" 
bgcolor="silver"&gt;Document charset&lt;/td&gt;
&lt;td align="center"&gt;'+xmldoc.charset+'&lt;/td&gt;&lt;/tr&gt;');
this.document.writeln('&lt;/table&gt;&lt;/center&gt;');
}
</pre>
<b><i>Свойства и методы элементов документа</i></b>
<TABLE BORDER=1 WIDTH=100%>
<TR VALIGN="TOP">
<th>type</th>
<td>Возвращает тип элемента. Это свойство может быть использовано для того, чтобы разделить имена тэгов и данные, содержащиеся внутри них. В данной версии анализатора определены следующие типы элементов:
<br>0 - элемент
<br>1 - текст
<br>2 - комментарий
<br>3 - Document
<br>4 - DTD</TD>
</TR>
<TR VALIGN="TOP">
<th>tagName</th>
<td>Возвращает или устанавливает название тэга(в виде строки с символами, приведенными к верхнему регистру). Названия метатэгов(например, &amp;lt;?xml?&amp;gt;)  начинаются с символа ?. Названия тэгов комментариев начинаются с символа !.  </TD>
</TR>
<TR VALIGN="TOP">
<th>text</th>
<td>Возвращает текстовое содержимое элементов и комментариев. </TD>
</TR>
<TR VALIGN="TOP">
<th>AddChild()</th>
<td>Добавление нового дочернего элемента и всех его потомков в текущую ветвь дерева. В качестве первого параметра этой  функции необходимо передать объект типа Element, который затем будет помещен в список дочерних элементов. Также необходимо задать индекс нового элемента в списке и в качестве последнего параметра обязательно передать значение -1. Т.к. в данной модели любой элемент в документе может иметь ссылку только на один родительский элемент, при выполнении данной процедуры у добавляемого объекта старая ссылка на родительский элемент теряется. Используя это свойство, можно перемещать элементы из одного XML- документа в другое, но  том случае, если у дочерних ссылок перемещаемого элемента существуют внешние ссылки или сами дочерние элементы ссылаются на внешние  возможно возникновение ошибки 
<I><br>elem.addChild(elem.children.item().
children.item(0),0,-1)</I></TD>
</TR>
<TR VALIGN="TOP">
<th>removeChild()</th>
<td>Удаляет дочерний элемент и всех его потомков. Элементы остаются в памяти и могут быть вновь добавлены к дереву при помощи метода addChild(). 
<I><br>elem.removeChild(elem.children.item(1))</I></TD>
</TR>
<TR VALIGN="TOP">
<th>parent</th>
<td>Возвращает указатель на текущий родительский элемент. Ссылки на родительский элемент имеют все элементы, за исключением корневого. </TD>
</TR>
<TR VALIGN="TOP">
<th>GetAttribute()</th>
<td>Возвращает значение указанного атрибута в виде текстовой строки. 
<I><br>elem.getAttribute("color")</I></TD>
</TR>
<TR VALIGN="TOP">
<th>SetAttribute()</th>
<td>Устанавливает указанный атрибут и его значение. Прежнее значение атрибута теряется
<I><br>elem.setAttribute("color","red")</I></TD>
</TR>
<TR VALIGN="TOP">
<th>removeAttribute()</th>
<td>Уничтожает указанный атрибут
<I><br>elem.removeAttribute("color")</I></TD>
</TR>
<TR VALIGN="TOP">
<th>children</th>
<td>Возвращает ассоциированный список дочерних элементов(коллекцию). Такой список позволяет приложению получать нужные элементы как по названию, так и по порядковому номеру при помощи метода <B>item()</B>. В том случае, если потомков у текущего элемента нет, функция возвратит null</TD>
</TR>
</TABLE>
<b>Пример использования</b>
<p align=justify>Вот пример использования описанных функций:
<pre>
&lt;script language="javascript"&gt;
&lt;!--
var xmldoc = new ActiveXObject("msxml");
var xmlsrc = "http://localhost/xml/sample.xml";
function parse(root){
 var i=0;
 if(root.type==0){
  this.document.writeln('&lt;UL&gt;Current tag is 
  '+root.tagName+' 
  (parent is '+root.parent+'). ');
 }else if(root.type==1){
  this.document.writeln('&lt;LI&gt;It is a text of 
  '+root.parent.tagName+' 
  element: &lt;i&gt;'+root.text+'&lt;/i&gt;&lt;/LI&gt;');
 }else{
  this.document.writeln('&lt;br&gt;&lt;br&gt;Error');
 }
  if(root.children!=null){
  this.document.writeln('It consist of 
  '+root.children.length+' elements:');
   for(i=0;i&lt;root.children.length;i++){
     parse(root.children.item(i));
   }
  }
else{
     this.document.writeln('&lt;/UL&gt;');
  }
}
function viewDocument(){
xmldoc.URL = xmlsrc;
this.document.writeln('&lt;body bgcolor="white"&gt;');
this.document.writeln('&lt;p&gt;&lt;center&gt;&lt;hr width=80%&gt;
XML sample page
&lt;hr width=80%&gt;&lt;/center&gt;&lt;p&gt;');
parse(xmldoc.root);
this.document.writeln('&lt;/body&gt;');
}
viewDocument();
//--&gt;
&lt;/script&gt;
</pre>
<p align=justify>Как видно из примера, в процессе обработки XML- документа  необходимо рекурсивно обходить все ветви создаваемого анализатором дерева, причем, на каждом шаге возможны следующие ситуации:
<UL>
<LI>Встретился новый элемент. В этом случае его название(задаваемое тэгом) доступно при помощи свойства tagName, а содержимое - свойством text. У любого непустого элемента существует хотя бы один потомок, представляющий собой содержимое этого элемента(в этом отличие представленной объектной модели msxml от реальной структуры документа - в XML под элементом понимается как название тэга, так и текстовое содержимое его)  
<LI>Встретилось текстовое поле. Это поле может быть либо комментарием, либо просто текстом, содержащемся  в текущем элементе 
</UL>
<p align=justify>Для обработки потомков текущего элемента используется метод item(), который вызывается в цикле столько раз, сколько потомков у текущего элемента. Обработка каждого дочернего элемента осуществляется вызовом этой же функции, в чем и заключается рекурсия.
<a name="p2">
<b>Использование ASP</b>
<p align=justify>Доступ к свойствам XML- анализатора возможен также из сценариев ASP(Active Server Pages), выполняющихся на стороне сервера. Если при написании ASP-модуля используется язык VBscript, то для создания объекта, представляющего XML- документ, необходимо включить следующее выражение:
<pre>Set myxml=Server.CreateObject("msxml")
</pre>
<p align=justify></i>Однако необходимо учитывать, что в качестве сервера в этом случае надо использовать Web- сервер, поддерживающий ISAPI, и так же на компьютере должны быть установлены или броузер Internet Explorer версии 4 и выше, или зарегистрированный в реестре ActiveX- компонент msxml.
<p align=justify>Вот пример использования свойств XML-документа в ASP- программе:
<pre>
&lt;%
Set myxml=Server.CreateObject("msxml")
myxml.url = "http://localhost/xml/sample1.xml"
url=myxml.url
Set root=myxml.root
version=myxml.version
charset=myxml.charset
%&gt;
&lt;html&gt;
&lt;body bgcolor="white"&gt;
&lt;center&gt;
&lt;table width=80%&gt;
&lt;tr&gt;
 &lt;td align="center" bgcolor="silver"&gt;URL&lt;/td&gt;
 &lt;td align="center"&gt;&lt;%=url%&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
 &lt;td align="center" bgcolor="silver"&gt;Version&lt;/td&gt;
 &lt;td align="center"&gt;&lt;%=version%&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
 &lt;td align="center" bgcolor="silver"&gt;Root element&lt;/td&gt;
 &lt;td align="center"&gt;&lt;%=root.tagName%&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
 &lt;td align="center" bgcolor="silver"&gt;Charset&lt;/td&gt;
 &lt;td align="center"&gt;&lt;%=charset%&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p align=justify>Создавая <b>msxml</b>- объект при помощи <b>CreateObject</b>, мы в дальнейшем вызываем его методы и свойства привычным нам способом. Отличается лишь способ вставки полученной информации в HTML- страницу - она генерируется не на стороне клиента, а приходит к нему в уже готовом виде. 
<p align=justify>В заключение хотелось бы отметить, что рассмотренные способы работы с XML- документами могут применяться для отображения их элементов на экране броузера. Не всегда они являются наиболее эффективными для форматирования текста - для каждого нового документа с измененной структурой требуются частично или полностью переписывать обработчик(в следующем разделе мы попробуем использовать для этих же целей стилевые таблицы XSL). Однако использование Java Script позволяет уже сегодня разрабатывать реальные Интернет- приложения, использующие встроенный в броузер клиента анализатор в качестве средства для доступа к структурированной информации XML.
<p><center><p>
<font size=-1>
<a href="part1.html">Назад</a> | <a href="index.html">Содержание</a> | <a href="part3.html">Вперед</a></font></center></p>

</body></html>